<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coach Jo Agile Game Hub</title>
<style>
  /* Base styles */
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; padding: 0; }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #1a1a2e; /* Dark blue background */
    color: white;
    display: flex;
    flex-direction: column;
  }
  header {
    background: #16213e; /* Slightly lighter blue */
    padding: 15px 20px;
    text-align: center;
    box-shadow: 0 4px 6px rgba(0,0,0,0.5);
    flex-shrink: 0; /* Prevent header from shrinking */
  }
  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 2rem;
    color: #e94560; /* Accent pink */
    letter-spacing: 1.5px;
  }
  main {
    flex: 1; /* Allow main content to grow */
    max-width: 800px;
    width: 100%; /* Ensure it takes available width */
    margin: 20px auto;
    padding: 0 20px 40px;
    text-align: center; /* Center buttons and wheel */
    display: flex;
    flex-direction: column;
    align-items: center; /* Center content vertically */
    justify-content: center; /* Center content horizontally */
  }

  /* --- Views --- */
  /* Helper class to hide views */
  .hidden-view { display: none !important; }

  #game-area {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
  }


  /* --- Modals --- */
  .modal {
    display: none; /* Hidden by default */
    position: fixed;
    z-index: 1000;
    left: 0; top: 0;
    width: 100%; height: 100%;
    overflow: auto;
    background-color: rgba(26, 26, 46, 0.95); /* Dark semi-transparent background */
    backdrop-filter: blur(3px);
    align-items: center; /* Center modal vertically */
    justify-content: center; /* Center modal horizontally */
  }
  .modal-content {
    background-color: #0f3460; /* Darker blue for modal content */
    /* margin: 6% auto; Removed margin for flex centering */
    padding: 30px 40px;
    border-radius: 20px;
    width: 90%;
    max-width: 520px;
    box-shadow: 0 0 40px rgba(233, 69, 96, 0.85); /* Pink shadow */
    color: white;
    display: flex;
    flex-direction: column;
    text-align: left; /* Align text left inside modal */
    position: relative; /* Needed for potential absolute elements inside */
  }
  .modal-content:focus {
    outline: none;
  }

  /* Name Modal Specifics */
  #name-modal .modal-content {
    align-items: center; /* Center items in name modal */
    text-align: center;
    max-width: 400px;
    /* margin-top: 10%; Removed margin */
  }
  #name-modal h2 {
    font-size: 1.8rem;
    margin-bottom: 20px;
    color: #fcd581; /* Accent yellow */
  }
  #player-name-input {
    width: 100%;
    max-width: 320px;
    font-size: 1.2rem;
    padding: 12px;
    border-radius: 12px;
    border: 2px solid transparent; /* Space for error border */
    margin-bottom: 20px;
    box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
    color: #333; /* Dark text for input */
    transition: border-color 0.3s ease;
  }
   #player-name-input.invalid {
       border-color: red;
   }
   #name-error {
       color: red;
       font-size: 0.9rem;
       height: 1.2em; /* Reserve space */
       margin-top: -15px;
       margin-bottom: 10px;
   }
  #name-submit-btn {
    background: #e94560; /* Pink button */
    padding: 15px 40px;
    font-size: 1.3rem;
    font-weight: 700;
    border-radius: 12px;
    border: none;
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(233,69,96,0.7);
    transition: background-color 0.3s ease;
  }
  #name-submit-btn:hover {
    background-color: #d43452; /* Darker pink on hover */
  }

  /* Game Selection */
  #game-selection {
    text-align: center;
    width: 100%;
  }
  #game-selection h2 {
    font-size: 2rem;
    color: #fcd581; /* Yellow title */
    margin-bottom: 25px;
  }
  .game-choice {
    margin: 10px 8px; /* Consistent margin with other buttons */
    padding: 18px 30px;
    font-size: 1.2rem; /* Slightly smaller */
    border-radius: 15px;
    cursor: pointer;
    border: 3px solid #e94560; /* Pink border */
    background: transparent;
    color: white;
    font-weight: 700;
    transition: background-color 0.3s, color 0.3s ease;
    display: inline-block;
    user-select: none;
    min-width: 220px; /* Ensure buttons have a minimum width */
  }
  .game-choice:hover {
    background-color: #e94560; /* Pink background on hover */
    color: white;
  }

  /* General Buttons */
  button {
    font-weight: 700;
    cursor: pointer;
    border: none;
    border-radius: 12px;
    padding: 14px 36px;
    font-size: 1.1rem;
    margin: 10px 8px;
    transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
    outline-offset: 2px;
    color: white; /* Default text color */
  }
  button:disabled {
    background: #6f6f6f !important; /* Greyed out, important to override specific styles */
    cursor: not-allowed !important;
    box-shadow: none !important;
    color: #ccc !important;
    opacity: 0.7;
  }

  /* Specific Buttons */
   #game-controls button {
       min-width: 150px; /* Give controls buttons some width */
   }
  #spin-btn {
    background: #e94560; /* Pink */
    box-shadow: 0 5px 10px rgba(233, 69, 96, 0.7);
  }
  #spin-btn:hover:not(:disabled) {
    background-color: #d43452; /* Darker pink */
  }
  #play-again-btn {
    background: #0f3460; /* Dark blue */
    color: #fff;
    box-shadow: 0 5px 10px rgba(15, 52, 96, 0.7);
  }
  #play-again-btn:hover:not(:disabled) {
    background: #0a2148; /* Darker blue */
  }
  #new-player-btn {
    background: #fcd581; /* Yellow */
    color: #0f3460; /* Dark blue text */
    box-shadow: 0 5px 10px rgba(252, 213, 129, 0.8);
  }
  #new-player-btn:hover:not(:disabled) {
    background: #e6ba4b; /* Darker yellow */
  }

  /* Wheel canvas */
  #wheel-container {
      position: relative;
      width: 350px; /* Fixed size for the container */
      height: 350px;
      margin: 15px auto 25px;
  }
  #wheel {
      display: block;
      width: 100%;
      height: 100%;
  }
  #wheel-pointer {
      position: absolute;
      left: 50%;
      top: -10px; /* Position above the wheel */
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 15px solid transparent;
      border-right: 15px solid transparent;
      border-top: 30px solid #e94560; /* Pink pointer */
      z-index: 10;
  }

  /* Text outputs */
   #game-info {
       margin-top: 15px;
       width: 100%;
   }
  #result {
    font-size: 1.5rem;
    font-weight: 700;
    margin-top: 15px;
    min-height: 40px; /* Ensure space for text */
    text-align: center;
    color: #e94560; /* Pink result text */
  }
  #scoreboard, #timer {
    margin-top: 10px; /* Reduced margin */
    font-size: 1.2rem; /* Slightly larger */
    font-weight: 600;
    color: #f0f0f0;
    text-align: center;
    min-height: 1.5em; /* Reserve space */
  }
  #timer {
    font-size: 1.4rem; /* Larger timer */
    font-weight: 700;
    color: #fcd581; /* Yellow timer text */
    margin-bottom: 15px; /* Add space below timer */
  }

  /* Quiz Modal */
  #quiz-modal .modal-content {
      max-width: 600px; /* Allow slightly wider quiz modal */
  }
  .question {
    font-size: 1.6rem;
    font-weight: 700;
    margin-bottom: 25px;
  }
  .progress {
    font-size: 1rem;
    margin-bottom: 15px;
    color: #fcd581; /* Yellow progress text */
    text-align: right; /* Align progress to the right */
  }
  .options button {
    background: #e94560; /* Pink option buttons */
    border: none;
    border-radius: 12px;
    padding: 15px;
    margin: 8px 0;
    font-size: 1.15rem;
    cursor: pointer;
    font-weight: 700;
    transition: background-color 0.3s ease, opacity 0.3s ease;
    color: white;
    box-shadow: 0 3px 6px rgba(233,69,96,0.7);
    display: block; /* Make buttons take full width */
    width: 100%;
    text-align: left; /* Align text left */
    opacity: 1;
  }
  .options button:hover:not(:disabled) {
    background-color: #d43452; /* Darker pink */
  }
  /* Style for disabled options during feedback */
   .options button:disabled {
       opacity: 0.6; /* General disabled opacity */
   }
  .options button.correct {
      background-color: #28a745 !important; /* Green for correct */
      color: white !important;
      box-shadow: none;
      opacity: 1 !important; /* Ensure correct answer is fully visible */
  }
  .options button.incorrect {
      background-color: #dc3545 !important; /* Red for incorrect */
      color: white !important;
      box-shadow: none;
      opacity: 0.7 !important; /* Make incorrect slightly more visible than just disabled */
  }
  .feedback {
    margin-top: 18px;
    font-weight: 700;
    font-size: 1.3rem;
    min-height: 36px; /* Ensure space for feedback */
    text-align: center; /* Center feedback */
  }
  #close-quiz-btn {
    align-self: flex-end; /* Position to the right */
    margin-top: 25px;
    background: #fcd581; /* Yellow */
    color: #0f3460; /* Dark blue text */
    padding: 12px 25px;
    font-weight: 700;
    font-size: 1.1rem;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    box-shadow: 0 3px 6px rgba(252, 213, 129, 0.8);
    transition: background-color 0.3s ease;
  }
  #close-quiz-btn:hover:not(:disabled) {
    background: #e6ba4b; /* Darker yellow */
  }

  /* Responsive */
  @media (max-width: 600px) {
    main {
      padding: 0 10px 20px;
      justify-content: flex-start; /* Align top on mobile */
      margin-top: 10px;
    }
    /* Stack buttons on smaller screens */
    button, .game-choice {
      width: 95%; /* Almost full width */
      font-size: 1.1rem;
      padding: 16px 0;
      margin: 10px auto; /* Center buttons */
      display: block;
      box-sizing: border-box;
    }
     #game-controls button {
         min-width: unset; /* Remove min-width on mobile */
     }
    #player-name-input {
      max-width: 95%;
    }
    .modal {
        align-items: flex-start; /* Align modal top */
        padding-top: 15%;
    }
    .modal-content {
      padding: 20px 25px;
      /* margin-top: 20%; Removed margin */
      width: 95%;
    }
    #wheel-container {
        width: 90%; /* Make wheel responsive */
        max-width: 300px; /* Max size on mobile */
        height: auto; /* Adjust height automatically */
        padding-top: 0; /* Remove padding hack */
        aspect-ratio: 1 / 1; /* Maintain aspect ratio */
    }
    #wheel-pointer {
        top: -5px; /* Adjust pointer position for smaller wheel */
        border-left-width: 10px;
        border-right-width: 10px;
        border-top-width: 20px;
    }
    header h1 { font-size: 1.8rem; }
    #game-selection h2 { font-size: 1.8rem; }
    .question { font-size: 1.4rem; }
    .options button { font-size: 1rem; }
    .feedback { font-size: 1.1rem; }
    /* Adjust wheel text size on smaller screens */
    #wheel {
        font-size: 12px; /* Adjust base font size if needed */
    }
  }
</style>
</head>
<body>

<header>
  <h1>Agile Game Hub</h1>
</header>

<main>
  <div id="name-modal" class="modal" aria-modal="true" role="dialog" aria-labelledby="name-modal-title">
    <div class="modal-content" tabindex="-1">
      <h2 id="name-modal-title">Welcome! Please enter your name</h2>
      <input type="text" id="player-name-input" placeholder="Your name here" aria-label="Player Name" autocomplete="off" />
       <div id="name-error"></div> <button id="name-submit-btn">Start Playing</button>
    </div>
  </div>

  <div id="game-area">
      <section id="game-selection" class="hidden-view" aria-label="Select an agile game to play">
        <h2>Select a game to play, <span id="player-greeting-name">Player</span>!</h2>
        <button class="game-choice" data-game="spinWheel">🎡 Spin Wheel Quiz</button>
        <button class="game-choice" data-game="kanbanQuiz">📋 Kanban Board Quiz</button>
        <button class="game-choice" data-game="userStoryQuiz">🧩 User Story Quiz</button>
        <button class="game-choice" data-game="retroQuiz">🔄 Retrospective Quiz</button>
        <button class="game-choice" data-game="valuesQuiz">📖 Agile Values Quiz</button>
      </section>

      <div id="spin-wheel-view" class="hidden-view">
          <div id="wheel-container">
               <canvas id="wheel" width="500" height="500" role="img" aria-label="Spin wheel with Agile quiz topics"></canvas>
               <div id="wheel-pointer"></div>
           </div>
      </div>

      <div id="game-info" class="hidden-view">
           <div id="timer" aria-live="polite" aria-atomic="true"></div>
           <div id="scoreboard" aria-live="polite" aria-atomic="true">Correct Answers: <span id="score">0</span></div>
           <div id="result" aria-live="polite" aria-atomic="true"></div>
       </div>

      <div id="game-controls" class="hidden-view">
          <button id="spin-btn" aria-live="polite">Spin the Wheel!</button>
          <button id="play-again-btn">Play Again</button>
          <button id="new-player-btn">New Player</button>
      </div>
  </div>

</main>

<div id="quiz-modal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="quiz-title" aria-modal="true">
  <div class="modal-content" tabindex="-1">
    <div class="progress" id="quiz-progress">Question 1 of 10</div>
    <div id="quiz-question" class="question" aria-live="polite"></div>
    <div class="options" id="quiz-options" role="group" aria-label="Answer options">
        </div>
    <div class="feedback" id="quiz-feedback" aria-live="assertive"></div>
    <button id="close-quiz-btn" aria-label="Close quiz modal">Close</button>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {

    // --- Constants ---
    const MAX_QUESTIONS_PER_GAME = 10;
    const SPIN_WHEEL_SEGMENTS = 6;
    const MAX_ATTEMPTS_PER_QUESTION = 2;
    const TOTAL_TIME = 120; // seconds
    const SEGMENT_COLORS = ['#FF6384','#36A2EB','#FFCE56','#9966FF','#FF9F40','#4BC0C0', '#FF6347', '#4682B4', '#32CD32', '#DAA520'];
    const UI_VIEWS = {
        NAME_ENTRY: 'nameEntry',
        GAME_SELECTION: 'gameSelection',
        GAME_AREA: 'gameArea', // Parent for wheel/info/controls
        SPIN_WHEEL_GAME: 'spinWheelGame', // Shows wheel + controls + info
        QUIZ_GAME: 'quizGame', // Shows info + controls (no wheel/spin)
        GAME_OVER: 'gameOver' // Shows info + end controls
    };

    // --- State ---
    const gameState = {
        playerName: localStorage.getItem('agilePlayerName') || '',
        score: 0,
        questionsAsked: new Set(),
        questionsCount: 0, // Questions answered/presented in current round
        currentAttempts: 0,
        currentQuestionIndex: null, // Index in the currentQuestions array
        currentGameKey: null, // e.g., 'spinWheel'
        currentQuestions: [], // Questions for the current game round
        currentSegments: [], // Wheel segments if applicable
        currentView: UI_VIEWS.NAME_ENTRY,
        isGameOver: false,
        timerInterval: null,
        timeLeft: TOTAL_TIME,
        isSpinning: false,
        spinTimeout: null,
        wheelStartAngle: 0, // Renamed from startAngle
        wheelCenterX: 0,
        wheelCenterY: 0,
        wheelRadius: 0
    };

    // --- DOM Elements ---
    const elements = {
        nameModal: document.getElementById('name-modal'),
        nameInput: document.getElementById('player-name-input'),
        nameError: document.getElementById('name-error'),
        nameSubmitBtn: document.getElementById('name-submit-btn'),
        gameArea: document.getElementById('game-area'),
        gameSelectionView: document.getElementById('game-selection'),
        playerGreetingName: document.getElementById('player-greeting-name'),
        gameChoiceBtns: Array.from(document.querySelectorAll('.game-choice')),
        spinWheelView: document.getElementById('spin-wheel-view'),
        wheelContainer: document.getElementById('wheel-container'),
        wheelCanvas: document.getElementById('wheel'),
        wheelCtx: document.getElementById('wheel').getContext('2d'),
        gameInfoView: document.getElementById('game-info'),
        timerDisplay: document.getElementById('timer'),
        scoreDisplay: document.getElementById('score'),
        resultDisplay: document.getElementById('result'),
        gameControlsView: document.getElementById('game-controls'),
        spinBtn: document.getElementById('spin-btn'),
        playAgainBtn: document.getElementById('play-again-btn'),
        newPlayerBtn: document.getElementById('new-player-btn'),
        quizModal: document.getElementById('quiz-modal'),
        quizProgress: document.getElementById('quiz-progress'),
        quizQuestion: document.getElementById('quiz-question'),
        quizOptions: document.getElementById('quiz-options'),
        quizFeedback: document.getElementById('quiz-feedback'),
        quizCloseBtn: document.getElementById('close-quiz-btn'),
    };

    // --- Game Data ---
    // Added 'topic' field for spinWheel questions
    const games = {
      spinWheel: {
          name: "Spin Wheel Quiz",
          questions: [
              { topic: "Prod Owner", q: 'Who is responsible for maximizing the value of the product in Scrum?', options: ['Scrum Master', 'Product Owner', 'Development Team', 'Stakeholders'], answer: 1 },
              { topic: "Kanban WIP", q: 'What does WIP stand for in Kanban?', options: ['Work In Progress', 'Work Is Planned', 'Workflow In Process', 'Work Item Priority'], answer: 0 },
              { topic: "Agile Values", q: 'Which is NOT one of the Agile Manifesto values?', options: ['Individuals and interactions over processes and tools', 'Working software over comprehensive documentation', 'Contract negotiation over customer collaboration', 'Responding to change over following a plan'], answer: 2 },
              { topic: "Retro Purpose", q: 'What is the main purpose of a Sprint Retrospective?', options: ['Plan the next sprint', 'Review the product', 'Inspect and adapt the process', 'Assign new tasks'], answer: 2 },
              { topic: "User Story", q: 'What is the typical format of a user story?', options: ['As a [role], I want [feature] so that [benefit]', 'When [event], then [result]', 'Given [context], when [event], then [outcome]', 'If [condition], then [action]'], answer: 0 },
              { topic: "Planning", q: 'What is a common Agile planning artifact?', options: ['Product Backlog', 'Gantt Chart', 'Critical Path', 'Waterfall Model'], answer: 0 },
          ]
      },
      kanbanQuiz: { name: "Kanban Board Quiz", questions: [ { q: 'What color is usually associated with “Blocked” in Kanban?', options: ['Red', 'Green', 'Blue', 'Yellow'], answer: 0 }, { q: 'What is the primary purpose of a Kanban board?', options: ['Track workflow', 'Plan sprints', 'Define roles', 'Estimate tasks'], answer: 0 }, { q: 'What does “Cumulative Flow Diagram” help visualize?', options: ['Task distribution', 'Cycle time', 'Workflow stability', 'User stories'], answer: 2 }, { q: 'Which of these is a WIP limit benefit?', options: ['Faster delivery', 'More multitasking', 'Team confusion', 'Longer sprints'], answer: 0 }, { q: 'Kanban originated from which industry?', options: ['Software', 'Manufacturing', 'Healthcare', 'Education'], answer: 1 }, { q: 'What is the first step in implementing Kanban?', options: ['Visualize workflow', 'Plan sprints', 'Assign roles', 'Set deadlines'], answer: 0 }, { q: 'What does "Lead Time" measure in Kanban?', options: ['Time from request to delivery', 'Time spent actively working', 'Time waiting in a queue', 'Time for daily standup'], answer: 0 }, { q: 'What is a "Swimlane" on a Kanban board used for?', options: ['Different types of work', 'Team members', 'Priority levels', 'Project phases'], answer: 0 }, { q: 'Which is NOT a core principle of Kanban?', options: ['Visualize workflow', 'Limit WIP', 'Manage flow', 'Assign story points'], answer: 3 }, { q: 'What is "Kaizen" in the context of Kanban?', options: ['Continuous improvement', 'Daily meeting', 'Work item', 'Workflow state'], answer: 0 }, ] },
      userStoryQuiz: { name: "User Story Quiz", questions: [ { q: 'What is the standard user story format?', options: ['As a [role], I want [feature] so that [benefit]', 'If [condition], then [action]', 'Given [context], when [event], then [outcome]', 'When [event], then [result]'], answer: 0 }, { q: 'User stories are usually written by?', options: ['Developers', 'Product Owners', 'Testers', 'Stakeholders'], answer: 1 }, { q: 'Which is a good characteristic of a user story (INVEST)?', options: ['Independent', 'Large', 'Ambiguous', 'Dependent'], answer: 0 }, { q: 'User stories are stored in the?', options: ['Product Backlog', 'Sprint Backlog', 'Kanban Board', 'Release Notes'], answer: 1 }, { q: 'What does the "V" in INVEST stand for?', options: ['Valuable', 'Visible', 'Verified', 'Volatile'], answer: 0 }, { q: 'Who prioritizes user stories?', options: ['Scrum Master', 'Product Owner', 'Developers', 'Testers'], answer: 1 }, { q: 'What are "Acceptance Criteria" for a user story?', options: ['Conditions the story must meet to be done', 'Technical implementation details', 'The benefit statement', 'The estimated effort'], answer: 0 }, { q: 'What is "Story Mapping"?', options: ['A technique to visualize the backlog', 'A way to estimate stories', 'A method for writing stories', 'A type of user role'], answer: 0 }, { q: 'An "Epic" is usually?', options: ['A large user story broken down later', 'A very small user story', 'A technical task', 'A bug report'], answer: 0 }, { q: 'What does the "T" in INVEST stand for?', options: ['Testable', 'Time-boxed', 'Technical', 'Trackable'], answer: 0 }, ] },
      retroQuiz: { name: "Retrospective Quiz", questions: [ { q: 'What is the main goal of a retrospective?', options: ['Inspect and adapt process', 'Plan next sprint', 'Discuss product features', 'Assign tasks'], answer: 0 }, { q: 'Which of these is a common retro format?', options: ['Start, Stop, Continue', 'Waterfall', 'Gantt Chart', 'Kanban Board'], answer: 0 }, { q: 'Retrospectives should happen?', options: ['Regularly (e.g., after each sprint)', 'Once a year', 'Only when problems occur', 'Daily'], answer: 0 }, { q: 'Which role typically facilitates retros?', options: ['Development Team', 'Scrum Master', 'Product Owner', 'Stakeholders'], answer: 1 }, { q: 'Retrospectives promote?', options: ['Continuous improvement', 'New requirements', 'Budget cuts', 'Deadline changes'], answer: 0 }, { q: 'A “Lean Coffee” is?', options: ['An agenda-less meeting format often used for retros', 'A sprint ceremony for planning', 'A coding practice', 'A testing method'], answer: 0 }, { q: 'What is the "Prime Directive" of retrospectives?', options: ['Ensuring psychological safety and focus on improvement', 'Finding who to blame for issues', 'Deciding on new features', 'Planning the next iteration'], answer: 0 }, { q: 'Which is NOT a typical phase of a retrospective?', options: ['Set the stage', 'Gather data', 'Generate insights', 'Assign blame'], answer: 3 }, { q: 'What is the output of a retrospective?', options: ['Action items for improvement', 'A list of bugs', 'The sprint plan', 'User stories'], answer: 0 }, { q: 'Who should attend the Sprint Retrospective?', options: ['The entire Scrum Team (PO, SM, Devs)', 'Only the Developers', 'Only the Scrum Master and Product Owner', 'Managers and Stakeholders'], answer: 0 }, ] },
      valuesQuiz: { name: "Agile Values Quiz", questions: [ { q: 'One Agile value is "Individuals and interactions over..."?', options: ['Processes and tools', 'Comprehensive documentation', 'Contract negotiation', 'Following a plan'], answer: 0 }, { q: 'Agile manifesto values emphasize?', options: ['Flexibility and responsiveness', 'Strict rules and processes', 'Heavy upfront documentation', 'Fixed scope and deadlines'], answer: 0 }, { q: 'Which is NOT one of the 12 Agile Principles?', options: ['Simplicity--the art of maximizing the amount of work not done--is essential.', 'Build projects around motivated individuals.', 'The most efficient communication is face-to-face conversation.', 'Comprehensive documentation is the primary measure of progress.'], answer: 3 }, { q: 'Agile promotes sustainable pace, meaning?', options: ['The team works consistent hours without burnout', 'The team works faster every sprint', 'The team takes long breaks', 'The team ignores deadlines'], answer: 0 }, { q: 'Agile team sizes are typically?', options: ['Small and cross-functional (3-9 members)', 'Large and hierarchical', 'Single developer focused', 'Composed only of managers'], answer: 0 }, { q: 'Agile encourages frequent delivery of?', options: ['Working software', 'Status reports', 'Detailed plans', 'Contracts'], answer: 0 }, { q: 'Customer collaboration over...?', options: ['Contract negotiation', 'Internal processes', 'Following a plan', 'Individual interactions'], answer: 0 }, { q: 'Responding to change over...?', options: ['Following a plan', 'Contract negotiation', 'Processes and tools', 'Comprehensive documentation'], answer: 0 }, { q: 'What is the primary measure of progress in Agile?', options: ['Working software', 'Completed documentation', 'Hours worked', 'Lines of code'], answer: 0 }, { q: 'Agile methodologies aim to empower?', options: ['Self-organizing teams', 'Project managers', 'Stakeholders', 'Individual heroes'], answer: 0 }, ] }
    };


    // --- Initialization ---
    function initializeApp() {
        console.log("Initializing App...");
        // Calculate wheel dimensions once
        gameState.wheelCenterX = elements.wheelCanvas.width / 2;
        gameState.wheelCenterY = elements.wheelCanvas.height / 2;
        // Adjust radius slightly to avoid drawing outside canvas edge
        gameState.wheelRadius = Math.min(elements.wheelCanvas.width, elements.wheelCanvas.height) / 2 * 0.9;

        // Attach Event Listeners
        attachEventListeners();

        // Determine initial view
        if (gameState.playerName) {
            elements.playerGreetingName.textContent = gameState.playerName;
            switchView(UI_VIEWS.GAME_SELECTION);
        } else {
            switchView(UI_VIEWS.NAME_ENTRY);
        }
        console.log("App Initialized. Current View:", gameState.currentView);
    }

    // --- UI Update & View Switching ---
    function switchView(view) {
        gameState.currentView = view;
        console.log("Switching View to:", view);

        // Hide all major view containers initially
        elements.nameModal.style.display = 'none';
        elements.gameSelectionView.classList.add('hidden-view');
        elements.spinWheelView.classList.add('hidden-view');
        elements.gameInfoView.classList.add('hidden-view');
        elements.gameControlsView.classList.add('hidden-view');
        elements.quizModal.style.display = 'none'; // Ensure quiz modal is hidden

        // Show the target view and configure its elements
        switch (view) {
            case UI_VIEWS.NAME_ENTRY:
                elements.nameModal.style.display = 'flex';
                elements.nameInput.focus();
                break;
            case UI_VIEWS.GAME_SELECTION:
                elements.playerGreetingName.textContent = gameState.playerName;
                elements.gameSelectionView.classList.remove('hidden-view');
                break;
            case UI_VIEWS.SPIN_WHEEL_GAME:
            case UI_VIEWS.QUIZ_GAME:
            case UI_VIEWS.GAME_OVER:
                // These views show game info and controls
                elements.gameInfoView.classList.remove('hidden-view');
                elements.gameControlsView.classList.remove('hidden-view');
                // Conditionally show wheel for spin game
                if (view === UI_VIEWS.SPIN_WHEEL_GAME) {
                    elements.spinWheelView.classList.remove('hidden-view');
                }
                updateGameUI(); // Update buttons/text based on game state
                break;
        }
    }

    // Updates dynamic elements within the game views (timer, score, buttons)
    function updateGameUI() {
        // Update Score and Timer display always when info view is visible
        elements.scoreDisplay.textContent = gameState.score;
        elements.timerDisplay.textContent = gameState.timeLeft >= 0 ? `Time left: ${gameState.timeLeft}s` : "Time's up!";

        // Update Button States
        const isSpinGame = gameState.currentGameKey === 'spinWheel';
        const maxQuestions = isSpinGame ? SPIN_WHEEL_SEGMENTS : MAX_QUESTIONS_PER_GAME;

        // Spin Button
        elements.spinBtn.style.display = isSpinGame ? 'inline-block' : 'none';
        elements.spinBtn.disabled = !isSpinGame || gameState.isSpinning || gameState.isGameOver || gameState.questionsCount >= maxQuestions;

        // Play Again / New Player Buttons (only visible at game over)
        elements.playAgainBtn.style.display = gameState.isGameOver ? 'inline-block' : 'none';
        elements.newPlayerBtn.style.display = gameState.isGameOver ? 'inline-block' : 'none';
    }

    // --- Event Listeners ---
    function attachEventListeners() {
        // Name Input
        elements.nameSubmitBtn.addEventListener('click', handleNameSubmit);
        elements.nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleNameSubmit();
        });

        // Game Selection
        elements.gameChoiceBtns.forEach(btn => {
            btn.addEventListener('click', () => handleGameSelection(btn.dataset.game));
        });

        // Game Controls
        elements.spinBtn.addEventListener('click', handleSpin);
        elements.playAgainBtn.addEventListener('click', handlePlayAgain);
        elements.newPlayerBtn.addEventListener('click', handleNewPlayer);

        // Quiz Modal
        elements.quizCloseBtn.addEventListener('click', handleQuizClose);
        // Option buttons listeners are added dynamically in showQuiz
    }

    // --- Event Handlers ---
    function handleNameSubmit() {
        const nameVal = elements.nameInput.value.trim();
        elements.nameInput.classList.remove('invalid');
        elements.nameError.textContent = ''; // Clear previous error

        if (nameVal.length > 0) {
            gameState.playerName = nameVal;
            localStorage.setItem('agilePlayerName', gameState.playerName);
            switchView(UI_VIEWS.GAME_SELECTION);
        } else {
            elements.nameInput.classList.add('invalid');
            elements.nameError.textContent = 'Please enter your name.';
            elements.nameInput.focus();
        }
    }

    function handleGameSelection(gameKey) {
        console.log("Game Selected:", gameKey);
        if (!games[gameKey]) {
            console.error("Invalid game key selected:", gameKey);
            return;
        }
        setupGame(gameKey);
    }

    function handleSpin() {
        if (gameState.isSpinning || gameState.isGameOver) return;
        spinWheel();
    }

    function handlePlayAgain() {
        if (gameState.currentGameKey) {
            setupGame(gameState.currentGameKey); // Restart current game type
        } else {
            // Should not happen in normal flow, but reset just in case
            resetApp();
        }
    }

    function handleNewPlayer() {
        resetApp();
    }

    function handleQuizAnswer(event) {
        const selectedButton = event.target;
        const selectedIndex = parseInt(selectedButton.dataset.index, 10);

        if (isNaN(selectedIndex) || gameState.currentQuestionIndex === null) {
            console.error("Error in handleQuizAnswer: Invalid index or state.");
            return; // Or handle more gracefully
        }

        const question = gameState.currentQuestions[gameState.currentQuestionIndex];
        if (!question) {
             console.error("Error in handleQuizAnswer: Question not found at index", gameState.currentQuestionIndex);
             return;
        }
        const correctAnswerIndex = question.answer;

        gameState.currentAttempts++;
        disableQuizOptions(true); // Visually disable while processing

        // Determine result and update UI
        if (selectedIndex === correctAnswerIndex) {
            // Correct Answer
            elements.quizFeedback.style.color = '#7CFC00';
            elements.quizFeedback.textContent = 'Correct! 🎉';
            selectedButton.classList.add('correct');
            gameState.score++;
            elements.scoreDisplay.textContent = gameState.score; // Update score immediately
            finalizeQuizAnswer();
        } else {
            // Incorrect Answer
            selectedButton.classList.add('incorrect');
            elements.quizFeedback.style.color = '#ff5555';
            const attemptsLeft = MAX_ATTEMPTS_PER_QUESTION - gameState.currentAttempts;

            if (attemptsLeft > 0) {
                // Allow another try
                elements.quizFeedback.textContent = `Incorrect. ${attemptsLeft} attempt(s) left. Try again!`;
                // Re-enable *other* options after a delay
                setTimeout(() => {
                    elements.quizOptions.querySelectorAll('button').forEach(btn => {
                        if (btn !== selectedButton) {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                        } else {
                            // Keep the incorrect one visually distinct but disabled
                            btn.style.opacity = '0.6';
                        }
                    });
                }, 700);
            } else {
                // No attempts left
                elements.quizFeedback.textContent = `Incorrect. The correct answer was: "${question.options[correctAnswerIndex]}"`;
                const correctButton = elements.quizOptions.querySelector(`button[data-index="${correctAnswerIndex}"]`);
                if (correctButton) {
                    correctButton.classList.add('correct'); // Highlight correct answer
                }
                finalizeQuizAnswer();
            }
        }
    }

     function finalizeQuizAnswer() {
        disableQuizOptions(false); // Final disabled state, show correct/incorrect
        elements.quizCloseBtn.disabled = false; // Enable close button

        const isSpinGame = gameState.currentGameKey === 'spinWheel';
        const maxQuestions = isSpinGame ? SPIN_WHEEL_SEGMENTS : MAX_QUESTIONS_PER_GAME;

        // Check if this was the last question
        if (gameState.questionsCount >= maxQuestions) {
            elements.quizCloseBtn.textContent = 'Finish Game';
        }
     }

    function handleQuizClose() {
        closeQuizModal();

        const isSpinGame = gameState.currentGameKey === 'spinWheel';
        const maxQuestions = isSpinGame ? SPIN_WHEEL_SEGMENTS : MAX_QUESTIONS_PER_GAME;

        // Check if game should end
        if (gameState.timeLeft <= 0 || gameState.questionsCount >= maxQuestions) {
            endGame(gameState.timeLeft <= 0);
        } else {
            // Continue game
            if (isSpinGame) {
                // Re-enable spin button if wheel game
                updateGameUI(); // Updates button states
            } else {
                // Move to next question in non-spin games
                nextQuestion();
            }
        }
    }


    // --- Game Logic Functions ---

    function setupGame(gameKey) {
        resetGameState(); // Reset counters, timer, questions etc.
        gameState.currentGameKey = gameKey;
        gameState.isGameOver = false;

        const gameData = games[gameKey];
        const isSpinGame = gameKey === 'spinWheel';
        const numQuestionsForGame = isSpinGame ? SPIN_WHEEL_SEGMENTS : Math.min(gameData.questions.length, MAX_QUESTIONS_PER_GAME);

        // Prepare questions
        if (isSpinGame) {
            gameState.currentQuestions = gameData.questions.slice(0, numQuestionsForGame);
            // *** FIX: Use question.topic for segment name ***
            gameState.currentSegments = gameState.currentQuestions.map((q, i) => ({
                name: q.topic || `Topic ${i + 1}`, // Use topic field, fallback to generic name
                color: SEGMENT_COLORS[i % SEGMENT_COLORS.length]
            }));
        } else {
            const shuffled = [...gameData.questions].sort(() => 0.5 - Math.random());
            gameState.currentQuestions = shuffled.slice(0, numQuestionsForGame);
            gameState.currentSegments = []; // No segments for non-spin games
        }

        // Update UI for the specific game type
        if (isSpinGame) {
            switchView(UI_VIEWS.SPIN_WHEEL_GAME);
            drawWheel(); // Draw initial wheel state
        } else {
            switchView(UI_VIEWS.QUIZ_GAME);
            startTimer(); // Start timer immediately for non-spin games
            nextQuestion(); // Show first question
        }
         // Ensure result display is cleared at the start
         elements.resultDisplay.textContent = `Starting ${gameData.name}...`;
         setTimeout(() => { elements.resultDisplay.textContent = ''; }, 1500); // Clear after delay
    }

    function startTimer() {
        stopTimer(); // Ensure no duplicate timers
        gameState.timeLeft = TOTAL_TIME;
        gameState.timerInterval = setInterval(() => {
            gameState.timeLeft--;
            updateGameUI(); // Update timer display

            if (gameState.timeLeft <= 0) {
                endGame(true); // End due to timeout
            }
        }, 1000);
        updateGameUI(); // Initial display
    }

    function stopTimer() {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
    }

    function spinWheel() {
        if (gameState.isSpinning || gameState.isGameOver) return;

        const isSpinGame = gameState.currentGameKey === 'spinWheel';
        const maxQuestions = isSpinGame ? SPIN_WHEEL_SEGMENTS : 0; // Only spin game has max questions limit for spinning

        if (gameState.questionsCount >= maxQuestions) {
             console.log("All questions answered, cannot spin.");
             endGame(false); // End game if somehow spin was clicked after completion
             return;
        }

        gameState.isSpinning = true;
        updateGameUI(); // Disable spin button visually
        elements.resultDisplay.textContent = 'Spinning...';

        // Start timer only on the *first* spin of the game
        if (gameState.questionsCount === 0 && gameState.timeLeft === TOTAL_TIME) {
            startTimer();
        }

        // Animation parameters
        const spinAngleVelocity = Math.random() * 10 + 10; // Initial velocity deg/frame equivalent
        const spinTimeTotal = Math.random() * 3000 + 5000; // Duration 5-8 seconds
        let spinTimeElapsed = 0;
        const frameDuration = 30; // ms per frame

        function rotateWheelFrame() {
            spinTimeElapsed += frameDuration;

            if (spinTimeElapsed >= spinTimeTotal) {
                stopSpinningAnimation();
                return;
            }

            // Ease-out function: slows down towards the end
            const timeFractionRemaining = 1 - (spinTimeElapsed / spinTimeTotal);
            const easedFraction = timeFractionRemaining * (2 - timeFractionRemaining); // Quadratic ease-out
            const currentAngleVelocity = spinAngleVelocity * easedFraction;

            gameState.wheelStartAngle += (currentAngleVelocity * Math.PI / 180);
            gameState.wheelStartAngle %= (2 * Math.PI);

            drawWheel();

            gameState.spinTimeout = setTimeout(rotateWheelFrame, frameDuration);
        }

        rotateWheelFrame();
    }

    function stopSpinningAnimation() {
        clearTimeout(gameState.spinTimeout);
        gameState.spinTimeout = null;
        // isSpinning remains true until quiz is closed

        const numSegments = gameState.currentSegments.length;
        if (numSegments === 0) {
             console.error("Wheel stopped but no segments defined.");
             gameState.isSpinning = false; // Reset flag
             updateGameUI();
             return;
        };
        const arcSize = 2 * Math.PI / numSegments;

        const pointerAngle = 3 * Math.PI / 2;
        const effectiveAngle = (2 * Math.PI - gameState.wheelStartAngle + pointerAngle) % (2 * Math.PI);
        let landedIndex = Math.floor(effectiveAngle / arcSize);

        landedIndex = (landedIndex + numSegments) % numSegments;

        console.log(`Wheel stopped. Angle: ${gameState.wheelStartAngle.toFixed(2)}, Effective Angle: ${effectiveAngle.toFixed(2)}, Initial Index: ${landedIndex}`);


        // Check if this question has already been asked
        if (gameState.questionsAsked.has(landedIndex)) {
            console.log(`Index ${landedIndex} already asked. Finding next available.`);
            let foundNext = false;
            for (let i = 1; i < numSegments; i++) {
                const nextIndex = (landedIndex + i) % numSegments;
                if (!gameState.questionsAsked.has(nextIndex)) {
                    landedIndex = nextIndex;
                    foundNext = true;
                    console.log(`Found next available index: ${landedIndex}`);
                    break;
                }
            }
            if (!foundNext) {
                console.log("All segments seem to be asked already.");
                endGame(false);
                return;
            }
        }

        gameState.questionsAsked.add(landedIndex);
        gameState.questionsCount++;
        gameState.currentQuestionIndex = landedIndex;
        // *** FIX: Use segment name from gameState for result display ***
        const segmentName = gameState.currentSegments[landedIndex]?.name || `Segment ${landedIndex + 1}`;
        elements.resultDisplay.textContent = `Landed on: ${segmentName}!`;

        setTimeout(() => {
             const questionToShow = gameState.currentQuestions[gameState.currentQuestionIndex];
             if (questionToShow) {
                 showQuizModal(questionToShow, gameState.questionsCount, numSegments);
             } else {
                 console.error(`Error: No question found at index ${gameState.currentQuestionIndex} after spin.`);
                 elements.resultDisplay.textContent = "Oops! Error selecting question.";
                 gameState.questionsAsked.delete(landedIndex);
                 gameState.questionsCount--;
                 gameState.isSpinning = false;
                 updateGameUI();
             }
        }, 700);
    }

    function nextQuestion() {
        if (gameState.currentGameKey === 'spinWheel') return;

        const gameData = games[gameState.currentGameKey];
        if (!gameData || !gameData.questions) {
            console.error(`Data missing for game ${gameState.currentGameKey}`);
            endGame(false); return;
        }
        const maxQuestions = Math.min(gameData.questions.length, MAX_QUESTIONS_PER_GAME);

        if (gameState.questionsCount >= maxQuestions || gameState.timeLeft <= 0) {
            endGame(gameState.timeLeft <= 0);
            return;
        }

        gameState.currentQuestionIndex = gameState.questionsCount;
        gameState.questionsAsked.add(gameState.currentQuestionIndex);
        gameState.questionsCount++;
        gameState.currentAttempts = 0;

        const questionToShow = gameState.currentQuestions[gameState.currentQuestionIndex];
        if (questionToShow) {
             showQuizModal(questionToShow, gameState.questionsCount, maxQuestions);
        } else {
             console.error(`Error: Invalid question index ${gameState.currentQuestionIndex} for non-spin game.`);
             endGame(false);
        }
    }

    function endGame(isTimeout) {
        console.log("Ending Game. Timeout:", isTimeout);
        stopTimer();
        gameState.isGameOver = true;
        gameState.isSpinning = false;
        clearTimeout(gameState.spinTimeout);

        const isSpinGame = gameState.currentGameKey === 'spinWheel';
        const totalPossibleQuestions = isSpinGame ? SPIN_WHEEL_SEGMENTS : Math.min(games[gameState.currentGameKey]?.questions?.length ?? 0, MAX_QUESTIONS_PER_GAME);
        const questionsAttempted = gameState.questionsCount;

        let endMessage = '';
        if (isTimeout) {
            endMessage = `Time's up! Final score: ${gameState.score} out of ${questionsAttempted} questions attempted.`;
        } else {
            const finalAnsweredCount = Math.min(questionsAttempted, totalPossibleQuestions);
            endMessage = `Game Over! You answered ${finalAnsweredCount} out of ${totalPossibleQuestions} questions and scored ${gameState.score}.`;
        }
        elements.resultDisplay.textContent = `${endMessage} Well done, ${gameState.playerName}!`;

        switchView(UI_VIEWS.GAME_OVER);
    }

    // --- Reset Functions ---
    function resetGameState() {
        gameState.score = 0;
        gameState.questionsAsked.clear();
        gameState.questionsCount = 0;
        gameState.currentAttempts = 0;
        gameState.currentQuestionIndex = null;
        gameState.currentQuestions = [];
        gameState.currentSegments = [];
        gameState.isGameOver = false;
        stopTimer();
        gameState.timeLeft = TOTAL_TIME;
        gameState.isSpinning = false;
        clearTimeout(gameState.spinTimeout);
        gameState.wheelStartAngle = 0;
    }

    function resetApp() {
        console.log("Resetting App...");
        resetGameState();
        gameState.playerName = '';
        gameState.currentGameKey = null;
        localStorage.removeItem('agilePlayerName');
        elements.nameInput.value = '';
        switchView(UI_VIEWS.NAME_ENTRY);
    }

    // --- Wheel Drawing ---
    function drawWheel() {
        const ctx = elements.wheelCtx;
        const numSegments = gameState.currentSegments.length;
        if (numSegments === 0 || !ctx) return;

        const { wheelCenterX: centerX, wheelCenterY: centerY, wheelRadius: radius, wheelStartAngle: startAngle } = gameState;
        const arcSize = 2 * Math.PI / numSegments;
        const textRadius = radius * 0.65;

        // Adjust font size based on radius for better fit
        const fontSize = Math.max(10, Math.min(16, Math.floor(radius / 12))); // Example dynamic font size
        ctx.font = `bold ${fontSize}px Segoe UI, Arial`;

        ctx.clearRect(0, 0, elements.wheelCanvas.width, elements.wheelCanvas.height);


        for (let i = 0; i < numSegments; i++) {
            const angle = startAngle + i * arcSize;
            ctx.fillStyle = gameState.currentSegments[i].color;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, angle, angle + arcSize, false);
            ctx.lineTo(centerX, centerY);
            ctx.fill();

            ctx.save();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.fillStyle = 'white';
            ctx.translate(
                centerX + Math.cos(angle + arcSize / 2) * textRadius,
                centerY + Math.sin(angle + arcSize / 2) * textRadius
            );
            ctx.rotate(angle + arcSize / 2 + Math.PI / 2);
             // *** FIX: Use segment name from gameState ***
            const text = gameState.currentSegments[i]?.name || ''; // Use optional chaining and fallback
            ctx.fillText(text, -ctx.measureText(text).width / 2, 0);
            ctx.restore();
        }

        // Center circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.15, 0, 2 * Math.PI);
        ctx.fillStyle = '#16213e';
        ctx.fill();
        ctx.strokeStyle = '#fcd581';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    // --- Quiz Modal Functions ---
    function showQuizModal(questionObj, currentNum, totalNum) {
        if (!questionObj) {
             console.error("showQuizModal called with null questionObj");
             return;
        }
        console.log(`Showing Quiz: Q${currentNum}/${totalNum}`, questionObj);
        gameState.currentAttempts = 0;
        elements.quizProgress.textContent = `Question ${currentNum} of ${totalNum}`;
        elements.quizQuestion.textContent = questionObj.q;
        elements.quizOptions.innerHTML = '';
        elements.quizFeedback.textContent = '';
        elements.quizFeedback.style.color = '';
        elements.quizCloseBtn.textContent = 'Close';
        elements.quizCloseBtn.disabled = true;

        questionObj.options.forEach((option, idx) => {
            const btn = document.createElement('button');
            btn.textContent = option;
            btn.disabled = false;
            btn.setAttribute('type', 'button');
            btn.dataset.index = idx;
            btn.addEventListener('click', handleQuizAnswer);
            elements.quizOptions.appendChild(btn);
        });

        elements.quizModal.style.display = 'flex';
        elements.quizModal.setAttribute('aria-hidden', 'false');
        elements.quizModal.querySelector('.modal-content').focus();
    }

    function disableQuizOptions(isChecking = false) {
         elements.quizOptions.querySelectorAll('button').forEach(btn => {
            btn.disabled = true;
             if (isChecking) {
                 btn.style.opacity = '0.7';
             } else {
                 if (!btn.classList.contains('correct') && !btn.classList.contains('incorrect')) {
                     btn.style.opacity = '0.6';
                 }
             }
         });
    }


    function closeQuizModal() {
        gameState.isSpinning = false; // Allow spinning again once quiz is closed
        elements.quizModal.style.display = 'none';
        elements.quizModal.setAttribute('aria-hidden', 'true');
        elements.quizOptions.innerHTML = '';
        elements.quizFeedback.textContent = '';
        if (gameState.currentGameKey === 'spinWheel' && !gameState.isGameOver) {
             // Only focus spin button if it's enabled
            if (!elements.spinBtn.disabled) {
                 elements.spinBtn.focus();
            }
        }
    }

    // --- Start the application ---
    initializeApp();

  });
</script>

</body>
</html>
